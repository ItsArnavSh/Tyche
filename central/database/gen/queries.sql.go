// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
)

const cleanupOldEntries = `-- name: CleanupOldEntries :exec
BEGIN
`

func (q *Queries) CleanupOldEntries(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldEntries)
	return err
}

const getDFI = `-- name: GetDFI :one
SELECT dfi FROM dictionary WHERE word_id = $1
`

func (q *Queries) GetDFI(ctx context.Context, wordID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getDFI, wordID)
	var dfi int32
	err := row.Scan(&dfi)
	return dfi, err
}

const getFreqList = `-- name: GetFreqList :many
SELECT word_id, lid, freq FROM invertedindex
WHERE word_id = $1
`

func (q *Queries) GetFreqList(ctx context.Context, wordID int32) ([]Invertedindex, error) {
	rows, err := q.db.QueryContext(ctx, getFreqList, wordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invertedindex
	for rows.Next() {
		var i Invertedindex
		if err := rows.Scan(&i.WordID, &i.Lid, &i.Freq); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelevantChunks = `-- name: GetRelevantChunks :many
SELECT lid
FROM vecdb
WHERE embedding <-> $1 < $2
ORDER BY embedding <-> $1
LIMIT $3
`

type GetRelevantChunksParams struct {
	Embedding   interface{} `json:"embedding"`
	Embedding_2 interface{} `json:"embedding_2"`
	Limit       int32       `json:"limit"`
}

func (q *Queries) GetRelevantChunks(ctx context.Context, arg GetRelevantChunksParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getRelevantChunks, arg.Embedding, arg.Embedding_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var lid int32
		if err := rows.Scan(&lid); err != nil {
			return nil, err
		}
		items = append(items, lid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWordID = `-- name: GetWordID :one
SELECT word_id FROM dictionary WHERE word = $1
`

// fallback query if INSERT returns nothing:
func (q *Queries) GetWordID(ctx context.Context, word string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWordID, word)
	var word_id int32
	err := row.Scan(&word_id)
	return word_id, err
}

const insertFreq = `-- name: InsertFreq :exec
INSERT INTO invertedindex (word_id, lid, freq)
VALUES ($1, $2, $3)
ON CONFLICT (word_id, lid)
DO UPDATE SET freq = EXCLUDED.freq
`

type InsertFreqParams struct {
	WordID int32 `json:"word_id"`
	Lid    int32 `json:"lid"`
	Freq   int32 `json:"freq"`
}

func (q *Queries) InsertFreq(ctx context.Context, arg InsertFreqParams) error {
	_, err := q.db.ExecContext(ctx, insertFreq, arg.WordID, arg.Lid, arg.Freq)
	return err
}

const insertOrGetWord = `-- name: InsertOrGetWord :one
INSERT INTO dictionary (word, dfi)
VALUES ($1, 0)
ON CONFLICT (word) DO NOTHING
RETURNING word_id
`

func (q *Queries) InsertOrGetWord(ctx context.Context, word string) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertOrGetWord, word)
	var word_id int32
	err := row.Scan(&word_id)
	return word_id, err
}

const upsertVector = `-- name: UpsertVector :exec
INSERT INTO vecdb (lid, embedding)
VALUES ($1, $2)
ON CONFLICT (lid)
DO UPDATE SET embedding = EXCLUDED.embedding
`

type UpsertVectorParams struct {
	Lid       int32       `json:"lid"`
	Embedding interface{} `json:"embedding"`
}

func (q *Queries) UpsertVector(ctx context.Context, arg UpsertVectorParams) error {
	_, err := q.db.ExecContext(ctx, upsertVector, arg.Lid, arg.Embedding)
	return err
}

const upsertWordAndIncrementDFI = `-- name: UpsertWordAndIncrementDFI :one
INSERT INTO dictionary (word, dfi)
VALUES ($1, 1)
ON CONFLICT (word)
DO UPDATE SET dfi = dictionary.dfi + 1
RETURNING word_id
`

func (q *Queries) UpsertWordAndIncrementDFI(ctx context.Context, word string) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertWordAndIncrementDFI, word)
	var word_id int32
	err := row.Scan(&word_id)
	return word_id, err
}
