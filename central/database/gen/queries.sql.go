// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
)

const cleanupOldEntries = `-- name: CleanupOldEntries :exec
BEGIN
`

func (q *Queries) CleanupOldEntries(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldEntries)
	return err
}

const getAverageDocLength = `-- name: GetAverageDocLength :one
SELECT AVG(con_size)::FLOAT FROM livefeed
`

func (q *Queries) GetAverageDocLength(ctx context.Context) (float64, error) {
	row := q.db.QueryRowContext(ctx, getAverageDocLength)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}

const getDFI = `-- name: GetDFI :one
SELECT dfi FROM dictionary WHERE word_id = $1
`

func (q *Queries) GetDFI(ctx context.Context, wordID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getDFI, wordID)
	var dfi int32
	err := row.Scan(&dfi)
	return dfi, err
}

const getDocSizeByLID = `-- name: GetDocSizeByLID :one
SELECT con_size FROM livefeed WHERE lid = $1
`

func (q *Queries) GetDocSizeByLID(ctx context.Context, lid int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getDocSizeByLID, lid)
	var con_size int32
	err := row.Scan(&con_size)
	return con_size, err
}

const getFreqList = `-- name: GetFreqList :many
SELECT word_id, lid, freq FROM invertedindex
WHERE word_id = $1
`

func (q *Queries) GetFreqList(ctx context.Context, wordID int32) ([]Invertedindex, error) {
	rows, err := q.db.QueryContext(ctx, getFreqList, wordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invertedindex
	for rows.Next() {
		var i Invertedindex
		if err := rows.Scan(&i.WordID, &i.Lid, &i.Freq); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeadline = `-- name: GetHeadline :one
SELECT headline FROM livefeed WHERE lid = $1
`

func (q *Queries) GetHeadline(ctx context.Context, lid int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getHeadline, lid)
	var headline string
	err := row.Scan(&headline)
	return headline, err
}

const getRelevantChunks = `-- name: GetRelevantChunks :many
SELECT lid
FROM vecdb
WHERE embedding <-> $1 < $2
ORDER BY embedding <-> $1
LIMIT $3
`

type GetRelevantChunksParams struct {
	Embedding   interface{} `json:"embedding"`
	Embedding_2 interface{} `json:"embedding_2"`
	Limit       int32       `json:"limit"`
}

func (q *Queries) GetRelevantChunks(ctx context.Context, arg GetRelevantChunksParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getRelevantChunks, arg.Embedding, arg.Embedding_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var lid int32
		if err := rows.Scan(&lid); err != nil {
			return nil, err
		}
		items = append(items, lid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalDocs = `-- name: GetTotalDocs :one
SELECT COUNT(*) FROM livefeed
`

func (q *Queries) GetTotalDocs(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalDocs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWordID = `-- name: GetWordID :one
SELECT word_id FROM dictionary WHERE word = $1
`

// fallback query if INSERT returns nothing:
func (q *Queries) GetWordID(ctx context.Context, word string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getWordID, word)
	var word_id int32
	err := row.Scan(&word_id)
	return word_id, err
}

const insertFreq = `-- name: InsertFreq :exec
INSERT INTO invertedindex (word_id, lid, freq)
VALUES ($1, $2, $3)  
ON CONFLICT (word_id, lid)
DO UPDATE SET freq = EXCLUDED.freq
`

type InsertFreqParams struct {
	WordID int32 `json:"word_id"`
	Lid    int32 `json:"lid"`
	Freq   int32 `json:"freq"`
}

func (q *Queries) InsertFreq(ctx context.Context, arg InsertFreqParams) error {
	_, err := q.db.ExecContext(ctx, insertFreq, arg.WordID, arg.Lid, arg.Freq)
	return err
}

const insertLivefeed = `-- name: InsertLivefeed :exec



INSERT INTO livefeed (lid, headline, con_size)
VALUES ($1, $2, $3)
`

type InsertLivefeedParams struct {
	Lid      int32  `json:"lid"`
	Headline string `json:"headline"`
	ConSize  int32  `json:"con_size"`
}

// id = db.InsertOrGetWord(word)
// if id == nil:
//
//	id = db.GetWordID(word)
func (q *Queries) InsertLivefeed(ctx context.Context, arg InsertLivefeedParams) error {
	_, err := q.db.ExecContext(ctx, insertLivefeed, arg.Lid, arg.Headline, arg.ConSize)
	return err
}

const insertWord = `-- name: InsertWord :one
INSERT INTO dictionary (word, dfi)
VALUES ($1, 0)
ON CONFLICT (word) DO NOTHING
RETURNING word_id
`

func (q *Queries) InsertWord(ctx context.Context, word string) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertWord, word)
	var word_id int32
	err := row.Scan(&word_id)
	return word_id, err
}

const upsertVector = `-- name: UpsertVector :exec
INSERT INTO vecdb (lid, embedding)
VALUES ($1, $2)
ON CONFLICT (lid)
DO UPDATE SET embedding = EXCLUDED.embedding
`

type UpsertVectorParams struct {
	Lid       int32       `json:"lid"`
	Embedding interface{} `json:"embedding"`
}

func (q *Queries) UpsertVector(ctx context.Context, arg UpsertVectorParams) error {
	_, err := q.db.ExecContext(ctx, upsertVector, arg.Lid, arg.Embedding)
	return err
}

const upsertWordAndIncrementDFI = `-- name: UpsertWordAndIncrementDFI :one
INSERT INTO dictionary (word, dfi)
VALUES ($1, $2)
ON CONFLICT (word)
DO UPDATE SET dfi = dictionary.dfi + $2
RETURNING word_id
`

type UpsertWordAndIncrementDFIParams struct {
	Word string `json:"word"`
	Dfi  int32  `json:"dfi"`
}

func (q *Queries) UpsertWordAndIncrementDFI(ctx context.Context, arg UpsertWordAndIncrementDFIParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertWordAndIncrementDFI, arg.Word, arg.Dfi)
	var word_id int32
	err := row.Scan(&word_id)
	return word_id, err
}
